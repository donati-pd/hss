% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pae.R
\name{pae}
\alias{pae}
\alias{pae_simple}
\alias{pae_mand}
\alias{pae_vol}
\title{Simulate populations and calculate estimates.}
\usage{
pae_mand(n, split = 1, success1, success0 = success1, resp, times = 1)

pae_simple(
  n,
  split = 1,
  success1,
  success0 = success1,
  sample,
  resp,
  bias,
  fus = FALSE,
  fus_scale = NULL,
  times = 1,
  poststrat = FALSE
)

pae_vol(
  n,
  split = 1,
  success1,
  success0 = success1,
  resp,
  bias,
  fus = FALSE,
  fus_sample = NULL,
  fus_scale = NULL,
  poststrat = FALSE,
  times
)
}
\arguments{
\item{n}{The desired population size.}

\item{split}{Proportion of the population that is placed into group 1.
The remaining proportion (i.e. \code{1 - split}) will be in group 0.}

\item{success1}{Probability of a hunter in group 1 to harvest}

\item{success0}{Probability of a hunter in group 0 to harvest}

\item{resp}{Probability/probabilities of response. Multiple values can be
passed to it.
\itemize{
\item In \code{pae_simple()} and \code{pae_vol()} it defines response
probabilities for unsuccessful hunters.
\item In \code{pae_mand()} it defines
response probabilities for successful hunters, as they are the only ones
mandated to report.
}}

\item{times}{The number of times to simulate responses from
the same population.}

\item{sample}{Probability a hunter is sampled for a survey}

\item{bias}{Introduces response bias if not equal to one. Scales \code{resp}
to create probabilities of response for successful hunters. Multiple values
can be passed to it.}

\item{fus}{Logical. If TRUE, a single follow up survey will be simulated.}

\item{fus_scale}{Scales initial response probabilities,
creating new probabilities of response for follow up surveys.}

\item{poststrat}{Logical. If \code{TRUE}, post-stratify respondents by the
\code{group} variable. If a follow up survey is simulated, it will also be
post-stratified. If \code{simdat} is from a \code{pop_mand()} output, the
population cannot be post-stratified. \code{survey::postStratify()} is used,
with the \code{partial} argument set to \code{TRUE}.}

\item{fus_sample}{Probability that a non-respondent is sampled for a follow
up survey.}
}
\value{
A tibble, containing an estimate of harvest for each level of
response rate, standard error, and absolute percent error, among
other important metadata.\cr\cr
}
\description{
The \code{pae} functions simulate \strong{p}opulations \strong{a}nd
\strong{e}stimate total harvest all in one step. They are
wrappers around their respective \code{\link{pop}} functions and the
\code{\link{est}} function. These functions are useful when you do not need
the actual population data and would like to skip that intermediate step.
\itemize{
\item \code{pae_mand()} simulates populations, mandates successful hunters
to report their harvest, and creates harvest estimates from responses.
\item \code{pae_simple()} simulates populations, surveys them using
simple random sampling, and creates harvest estimates from responses.
\item \code{pae_vol()} simulates populations, allows both successful and
unsuccessful hunters to voluntarily report, and creates harvest estimates
from responses.
}
}
\details{
These functions provide an easy way to replicate multiple simulations within
a single function. Be aware that depending on how you define arguments, these
functions may take a long time to execute. Large populations, long vectors
for \code{resp} and/or \code{bias}, and completing many
simulations using \code{times} can all take a while
to execute.
}
\examples{
# Calculate harvest estimates from a population that was surveyed using a
# simple random sample:
dat <- pae_simple(
  n         = 1000,
  split     = 0.7,
  success1  = 0.25,
  success0  = 0.6,
  sample    = 0.5,
  resp      = seq(0.2, 0.8, 0.2),
  resp_bias = c(1, 1.1, 1.2),
  fus       = TRUE,
  fus_scale = 0.7,
  poststrat = FALSE,
  times     = 100
)

}
\seealso{
\code{\link{pop}} and \code{\link{est}} to better understand the functions
that these are wrappers for.
}
